== AssertJ examples.

In our course we to stick to https://assertj.github.io/doc/[AssertJ] library where possible.

The rationale for that is:

* The AssertJ assertion API is very powerful and can easily turn overly strict or brittle tests into more effective tests. +
  You have come across tests in the mooc that insisted on specific formatting.
  With AssertJ you can specify elements you want to see and do not want to see. See examples below.
* AssertJ tests tend to be quite *readable*, once you get used to the fluent style. You will see long method names,
  but they help understanding what is going on a no-brainer.
* AssertJ can protect the test methods against unexpected exceptions, such as null pointers (NPE) before doing further tests.
* With the exception of _testing exceptions_, the userinterface and api of AssertJ is quite consistent. +
  You always start with `assertThat( objectOfInterest ).assertingMethod(...)`. +

We try to use the latest stable version of AssertJ and Junit 5.

[TIP]
====
Either use sebipom version 3.0.0 and up or add assertj.core to your test dependencies.
====

=== Simple Tests

.test boolean value.
[source,java]
----
  car.start();
  assertThat( car.motorIsOn() ) // <1>
      .as("Motor should be on after start") // <2>
      .isTrue(); //<3>
----

<1> Object of interest, return value of method, which in the test fails if not true.
<2> Optional description, use in particular when testing primitive values such as boolean. +
  Use it to improved the information you get when the test fails.
<3> The actual verification. Use `isTrue()` and `isFalse()` for `boolean`, `isEqualTo()` and `isEquals()` for other types.

.Another SimpleTest
[source,java]
----
  assertThat(car.speedLimit())
      .as("Make it a legal car?")
      .isEqualTo(250);
----

.Equals or same?
[source,java]
----
    assertThat( f1Champ ).isEqualTo( louis );
    assertThat( f1Champ ).isSameAs( louis );
----

Quiz: what is the difference between the two here: equals and same?

[TIP]
====
To follow along, tweak your IDE. Make sure you have the link:/2021/tips.html#_adding_your_own_code_templates_to_netbeans_ide[code template] to create a test method.
Note that the template adds a *fail* line, which should be disabled once the test and the business code agree.
====

=== String Containment

.test string containment
[source,java]
----
  Student student = ....

  assertThat( student.toString() )
      .isNotNull()                              // <1>
      .doesNotContainIgnoringCase("student{")    // <2>
      .contains( "Harry", "Potter", "1980-07-31", "12345"); //<3>
----

<1> Ensure that the next test can inspect a String without tripping over a NPE.
<2> _Auto generated is too simple._ Such autogenerated string typically starts with "Student{" for NetBeans IDE.
<3> The test ensures that the birth date is contained, and 12345 is Harry's student number.

How the string is formatted does not matter for this test to pass. It only requires the shown strings in any order.

=== Collection Containment

For collections there are numerous tests. Collections in this context includes
everything https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Iterable.html[Iterable],
making it very powerful as can be seen in the Javadoc page of Iterable
by following the link in this sentence. Look at the sub-interfaces and the implementing classes.

.simple containment.
[source,java]
----
    List<Professor> professors = List.of( SNAPE, DUMBLEDORE, MCGONAGALL ); //<1>

    List<Professor> teachesTransfiguration = professors.stream()
            .filter( p -> p.teaches( "Transfigurations" ) ).collect( toList() );

    assertThat( teachesTransfiguration )
            .isNotNull()                         //<2>
            .hasSizeGreaterThanOrEqualTo( 2 )    //<3>
            .contains( DUMBLEDORE, MCGONAGALL ); //<4>
----

<1> Assume this to be in the business code or SUT.
<2> Not really required by a good tip to make sure the test does not trip
  over an NPE, which might be confusing.
<3> The following contains test makes this actually redundant
<4> because we want these two at least.

[source,java]
----
//  List<Student> hogwartsStudents = ...; // <1>
  List<Student> hogwartsStudents = List.of( HARRY, HERMIONE, RON ); //<1>

  assertThat( hogwartsStudents )
          .isNotNull()                                // <2>
          .hasSizeGreaterThanOrEqualTo( 3 )           // <3>
          .extracting( s -> s.getStudentNumber() )    // <4>
          .containsExactlyInAnyOrder( 12346, 12345, 12347 ); // <5>
----

<1> Assume that the business code produces such list.
<2> Mostly self (test) protect.
<3> Just to show that you can test for not empty, but also exact size, greater etc. This assertion is actually made redundant by the test in 5.
<4> Extract a feature out of each student using a lambda. Its function should be obvious
<5> Then test the list of extracted values for containment.

[TIP]
====
Because adding a *Non-Null* test is easy and cheap in the fluent style of AssertJ,
it can be beneficial to always do that, so your test can show it as a failure instead of tripping over
an unexpected https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html[NPE].
It more or less self-protects the test.
====

=== Assert Exceptions

In most business processes you want to avoid exceptions, but when they are expected,
they must be thrown by the code under test, so that too needs to be tested.

There are three cases:

. You are not expecting an exception and do not (want to) care about it. +
  Then let it simply occur and if it is a checked exception make your test method throw it.
. You want specific code [red,bold]*not* to throw an exception and your want to test for that. +
  Wrap the suspect code in a lambda and invoke it using `assertThatCode( suspectCode )`.
. You [green,bold]*want* a specific exception to be thrown under specific a circumstance. +
  Wrap the exception causing code in a lambda and catch and inspect the resulting exception using `assertThatThrownBy( causingCode )`.

In AssertJ the exception testing helper have a format that deviates from the `assertThat().someCheck(...)` style.
This inconsistency has to do with the way the exceptions causing code must be called, and cannot easily be avoided.
We propagate one form, declaring a lambda first and use that as the parameter to exception asserter.

==== Ignore or pass on
In case you are not interested in an exception in your test, but it is a checked exception, simply declare your test method to throw it.

.Case 1: not interested in the (checked) exception, add a throws clause.
[source,java]
----
    @Test
    public void fileUsingMethod() throws IOException { // <1>
        Files.lines(Path.of ("puk.txt") );  // <2>
    }
----

<1> This code potentially throws an `IOException`, but you are not interested in testing the exception. If it occurs,
 let the caller (Test Runner) deal with this unexpected situation. The IOException is an example.
<2> This is the method that throws the checked exception. This is an example. Normally it should be a business method.


==== Exception NOT wanted.
If you want the check for an exception NOT to occur when invoking a code sequence, isolate the sequence
in a lambda expression of the form  `ThrowingCallable code =() -> { suspectCode(); }`. +
ThrowingCallable is a Functional interface and is part of AssertJ.

.Case 2: the business code should explicitly NOT throw an exception.
[source,java]
----
    Student draco = new Student("Draco", "Malfoy", LocalDate.of (1980,6,5));
    ThrowingCallable code = () -> {
        hogwarts.addStudent( draco );  // <1>
    };

    assertThatCode( code)
            .as( "draco should be accepted to make the adventures possible")
            .doesNotThrowAnyException();
----

<1> Is the only code that is checked for exceptions. This isolates the "suspect" code from
any other code that may cause issues.

[NOTE]
====
Sometimes you may have the situation that exceptions appear to come out of the blue, as in you have
no idea what causes it and the stack trace is not very helpful either. In such cases, use this test method
to isolate the problematic code.
====

==== Exception needs to occur.

When you want your business code to throw an exception, wrap that business code (the method invocations) in a lambda expression,
in the same way as in the previous paragraph, then pass that `code` to the exception assert method.

.Catch a specific exception.
[source,java]
----
    @Test
    public void addIllegalProfessor() {
        var malfoy = new Professor( "Lucius", "Malfoy", LocalDate.of( 1953, 10, 9 ) ); //<1>

        ThrowingCallable code = () -> { // <2>
            hogwarts.addProfessor( malfoy );
        };

        assertThatThrownBy( code )
                .isInstanceOf( Exception.class) // <3>
                .isExactlyInstanceOf( IllegalArgumentException.class) // <4>
                .hasMessageContainingAll( "should","teach"); // <5>
        // fail( "addIllegalProfessor completed succesfully; you know what to do" );
    }
----

<1> Someone that knows his classics understands that this crook can't be professor at Hogwarts.
<2> The lambda defines the throwing code. `org.assertj.core.api.ThrowableAssert.ThrowingCallable` is the functional interface for this purpose.
<3> Sometimes it is good to be a bit relaxed on the exception type like in this line.
<4> Or you need to be quite specific. You need only one, so choose either line 2 or 3. This is just an illustration.
<5> You might want to inspect the message for keywords.

In this fluent style you can check many more things. See the https://assertj.github.io/doc/[AssertJ user guide]
and https://javadoc.io/doc/org.assertj/assertj-core/latest/index.html[API] for that.

[TIP]
====
The general advise is to have only one (1) assert per test method. This makes the test method very focused.
Stick to this rule and do not test unrelated features.
Also note that when a failure occurs (a test fails or an exception is thrown), the rest of the test is not executed anymore,
and this will therefor obscure further asserts in the same test method.
====
